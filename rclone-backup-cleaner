#!/bin/bash


# THIS SCRIPT IS CURRENTLY A PROTOTYPE, DO NOT USE!


rcl () {
    # Executes rclone with the given options
    eval "$RCLONE_PATH ${RCLONE_OPTS[@]} $@"
}

print_documentation () {
    # Prints documentation
    cat << EOF

An interactive script for cleaning rclone backups created with --backup-dir.
Doesn't work for renamed files, as it only checks files with matching
filenames.

CAN BE DESTRUCTIVE. This is an interactive script, but careless use can still
result in data loss, although only in the backup directory. This script will
never touch files in the given source directory.

Files will be categorized, and asked to be deleted, when a matching filename in
both the source and backup directories matches one of the following criteria:

- Identical size & modification times
- Identical hashsums (with option --hashsum hash_name)

In addition, empty directories can be deleted in the backup directory with
--rmdirs.
EOF
}

print_help () {
    # Prints a help message
    cat << EOF
usage: $(basename "$0") [OPTION...] -s /source/dir -b /backup/dir

options:
  -h, --help                output this message
  --help-all                output documentation in addition to this message

  -s, --source-dir          the backup's source directory
  -b, --backup-dir          the backup directory
  --suffix                  use if this flag was used with --backup-dir
  --suffix-keep-extension   use if this flag was used with --backup-dir

  -c, --no-color            do not use colored output
  -q, --quiet               only print important information

  -r, --rclone-opts         options to pass to rclone
  -p, --rclone-path         path to rclone, if it doesn't exist in PATH
  --rmdirs                  remove empty directories in the backup directory
  --hashsum hash_name       delete files with matching hashsums
  --download                when using --hashsum, also use this option if the
                            remote doesn't natively support calculating hashsums
EOF
}

print_error () {
    # Prints an error message

    echo -e "${COLOR_ERROR}error: $@$COLOR_END"
}

print_important () {
    # Prints an important message, taking into account the verbosity level

    if [[ $QUIET = true ]]; then return 0; fi
    echo -e "$COLOR_IMPORTANT$@$COLOR_END"
}

print_message () {
    # Prints a message, taking into account the verbosity level

    if [[ $QUIET = true ]]; then return 0; fi
    echo "$@"
}

list_files () {
    # Recursively lists files in the given directory, formatted with -F

    rcl lsf --format "tsp" -R --files-only "'$1'" \
        | sed 's,^\(....-..-..\) ,\1T,g'
}

CACHE_SOURCE=$HOME/.cache/$(basename $0)-$$-source
CACHE_BACKUP=$HOME/.cache/$(basename $0)-$$-backup

# Parse arguments
ARGS=()
COLORED_OUTPUT=false
COLOR_END="\033[0m"
COLOR_IMPORTANT="\033[1;34m"
COLOR_ERROR="\033[1;31m"
RCLONE_PATH=$(which rclone)
SUFFIX_USED=false
EXTENSION_KEPT=false
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            print_help
            exit 0
            ;;
        --help-all)
            print_help
            print_documentation
            exit 0
            ;;
        -b|--backup-dir)
            BACKUP_DIR="$2"
            shift
            shift
            ;;
        -s|--source-dir)
            SOURCE_DIR="$2"
            shift
            shift
            ;;
        -c|--color)
            COLOR_END=""
            COLOR_IMPORTANT=""
            COLOR_ERROR=""
            shift
            ;;
        -q|--quiet)
            QUIET=true
            shift
            ;;
        -r|--rclone-options)
            RCLONE_OPTS="$2"
            shift
            shift
            ;;
        --suffix)
            SUFFIX_USED=true
            shift
            ;;
        --suffix-keep-extension)
            EXTENSION_KEPT=true
            shift
            ;;
        -p|--rclone-path)
            if [ -x $2 ]; then
                RCLONE_PATH="$2"
            else
                print_error "not an executable: '$2'"
                exit 1
            fi
            shift
            shift
            ;;
        *)
            print_error "unknown option: '$1'"
            exit 1
            ;;
    esac
done

# If source and backup directories haven't been set, print the help message and
# exit
if [[ -z "$SOURCE_DIR" || -z "$BACKUP_DIR" ]]; then
    print_help
    exit 0
fi

# Cache file lists
print_message "Listing source files from '$SOURCE_DIR'"
list_files "$SOURCE_DIR" > "$CACHE_SOURCE"
print_message "Listing backup files from '$BACKUP_DIR'"
list_files "$BACKUP_DIR" > "$CACHE_BACKUP"

# Exit if either of the directories is empty
if [[ $(du "$CACHE_SOURCE" | cut -f1) -eq 0 ]]; then
    print_important "source directory '$SOURCE_DIR' is empty, exiting"
    exit 0
fi
if [[ $(du "$CACHE_BACKUP" | cut -f1) -eq 0 ]]; then
    print_important "backup directory '$BACKUP_DIR' is empty, exiting"
    exit 0
fi



# TODO: rest of the owl


# Delete cache files
rm "$CACHE_SOURCE"
rm "$CACHE_BACKUP"
